
## Serve the model through a plumber API

## run in console
# plumber::plumb("3_deploy_model.R") |> plumber::pr_run(port = 8080, host = "0.0.0.0")
## run in terminal
# Rscript -e 'plumber::plumb("3_deploy_model.R") |> plumber::pr_run(port = 8080, host = "0.0.0.0")'

# Generated by the vetiver package; edit with care

library(pins)
library(plumber)
library(rapidoc)
library(vetiver)
library(DALEXtra)
library(dplyr)
library(parsnip)
library(ranger)
library(workflows)

model_name <- "churn_model_xgboost"
model_explainer <- "churn_model_xgboost_churn-explainer"
board <- pins::board_folder("./model_versions")

model_version <- board |> 
  pins::pin_versions(model_name) |>
  dplyr::arrange(desc(created)) |>
  dplyr::slice(1) |>
  dplyr::pull(version)

# this is weak, we need to connect to the model 
# version and the explainer version

explainer_version <- board |> 
  pins::pin_versions(model_explainer) |>
  dplyr::arrange(desc(created)) |>
  dplyr::slice(1) |>
  dplyr::pull(version)

model <- board |>
  vetiver::vetiver_pin_read(
    name = model_name, 
    version = model_version
  )

explainer <- board |> 
  pins::pin_read(
    name = model_explainer, 
    version = explainer_version
  )

handler_explain <- function(req) {

  shap <- predict_parts(
    explainer = explainer,
    new_observation = req$body,
    type = "shap",
    B = 20
  )

  shap %>%
    group_by(variable) %>%
    summarize(mean_val = mean(contribution), sd_val = sd(contribution)) %>%
    arrange(mean_val)
}

#* @plumber
function(pr) {
  pr %>%
    vetiver_api(model) %>%
    pr_post(path = "/explain", handler = handler_explain)
}
